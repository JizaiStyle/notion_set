<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My p5.js Sketch</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>

const numPoints = 160;
const meanRad = 100;

//const strokeCol = '#F3EFE0';
const backgroundCol = '#F3EFE0'
let fillCol1 = '#434242';
let fillCol2 = '#222222';

const speed = 0.5;

let stages = [];
let currentStage = 0;
let nextStage = 1;

let specialX = -5;

let t = 0;

function setup() {
	describe("gray squares tile the screen at a sligth angle. they move in steps while morphing into spheres and back into squares. One square is different then the others in that it is colored bright red")
	createCanvas(windowWidth, windowHeight);
	
	//strokeWeight(5);
	//stroke(strokeCol);
	noStroke();
	fill(fillCol1);
	
	stages = initStages();
}

function draw() {
	translate(width / 2, height / 2);
	background(backgroundCol);
	
	t += deltaTime * 0.001 * speed;
	
	if(t >= 1) {
		if(nextStage >= stages.length - 1) {
			currentStage = 0;
			nextStage = 1;
		} else {
			currentStage = nextStage;
			nextStage = (nextStage + 1) % stages.length;
		}
		t -= 1;
		
		let temp = fillCol1;
		fillCol1 = fillCol2;
		fillCol2 = temp;
		
		if(specialX >= width / (meanRad * 4) - 1) {
			specialX = - round(width / (meanRad * 4) + 1);
		}
		
		specialX++;
		
		//console.log(specialX + " | " + (width / (meanRad * 4) - 1));
	}
	//console.log(t + " c: "  + currentStage + " | n: " + nextStage)
	
	scaledT = -cos(t * PI) * 0.5 + 0.5;
	
	//fill(lerpColor(color(fillCol1), color(fillCol2), easings[currentStage](scaledT)));
	
	let points = getPoints();
	let numX = width / (meanRad * 4);
	let numY = height / (meanRad * 4);
	for(let y = - floor(numY); y <= numY; y++) {
		for(let x = - floor(numX); x <= numX; x++) {
			let dynamicOffset = scaleMoveAnimation(t) * (abs(y % 2 == 0)? 1 : -1);
			fill((x + y) % 2 == 0? fillCol1 : fillCol2);
			if(x == specialX && y == 0) {
				fill('red');
			}
			drawShape((x + dynamicOffset) * meanRad * 4, (4 * y + x + dynamicOffset) * meanRad, points);
		}
	}
}

function getPoints() {
	let points = [];
	
	let stageA = stages[currentStage];
	let stageB = stages[nextStage];
		
	let easedT = easings[currentStage](scaledT);
	
	for(let i = 0; i < numPoints; i++) {
		pA = stageA[i];
		pB = stageB[i];
		let delta = p5.Vector.sub(pB, pA);
		
		points.push(p5.Vector.add(pA, p5.Vector.mult(delta, easedT)));
	}
		
	return points;
}

function drawShape(dx, dy, points) {
	beginShape();
	for(let i = 0; i < points.length; i++) {
		vertex(points[i].x + dx, points[i].y + dy);
	}
	endShape(CLOSE);
}

function scaleMoveAnimation(x) {
	let moveWindow = 0.25;
	if(x < 0) {
		return 0;
	} else if(x < moveWindow) {
		return -cos(x * PI / moveWindow) * 0.5 + 0.5;
	} else {
		return 1;
	}
}
    </script>
</body>
</html>
